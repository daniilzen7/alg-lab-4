import random
import numpy as np

n = 26 # kolichestvo matric
p = []

for i in range(n): # имитация 26 матриц от A до Z (записываем только их размеры)
    a = random.randint(2, 100)
    p.append(a) # на первом месте стоит количество строк первой матрицы
    # так как количество столбцоы первой матрицы равно количеству строк второй,
    # то запишем только одно число - количество строк первой
p.append(random.randint(2, 100))
    # в конце записываем количество столбцов последней матрицы 

#p = [30, 35, 15, 5, 10, 20, 25]

m = np.zeros((n, n))
'''
здесь храним колиечство операций для умножений матриц
от i до j
'''


def mult(i, j): # рекурсивный метод
    global m
    global p
    if i != j: # это значит что мы считаем произведение одной матрицы, значит количество операций = 0
        if m[i][j] == 0:
            for k in range(i, j):
                '''
                Предположим, что при оптимальной расстановке скобок в произведении Ai * … * Aj 
                последней операцией умножения будет (Ai * … * Ak ) * (Ak+1 * … * Aj). 
                Значение m[i, j] равно сумме минимальной стоимости вычислений Aik и Ak+1j плюс 
                стоимость умножения этих двух матриц. При этом число k может принимать 
                только j – i разных значений: i, i + 1, …, j – 1. 
                Поскольку только одно из них является оптимальным, то необходимо
                перебрать все эти значения и выбрать наилучшее. 
                Получим рекуррентную формулу:
                '''
                tek = mult(i,k) + mult(k+1,j) + p[i] * p[k+1] * p[j+1]
                if tek < m[i][j] or m[i][j] == 0:
                    m[i][j] = tek #записываем минимум 
    return m[i][j]

mult(0, n-1)
print('входные матрицы (строки матриц и столбец последней мтарицы):', p)
print('минимальное количество операций для умножения входных матриц:', end=' ')
print(m[0][n-1])